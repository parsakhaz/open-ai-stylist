import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { v4 as uuidv4 } from 'uuid';
import { Message } from 'ai';

// Interfaces for our data structures
// The new, richer Product definition for our entire application.
export interface Product {
  id: string;
  name: string;
  imageUrl: string;
  buyLink: string;
  price: string | null;
  originalPrice: string | null;
  rating: number | null;
  ratingCount: number | null;
  isPrime: boolean;
}
export interface ModelImage { id: number; url: string; status: 'validating' | 'approved' | 'failed'; reason?: string; }
export interface MoodboardItem extends Product { tryOnUrl?: string; }
export interface Moodboard { id: string; title: string; description: string; items: MoodboardItem[]; isAutoGenerated?: boolean; }

// Interface for a chat session summary
export interface ChatSession {
  id: string;
  title: string;
  createdAt: Date;
}

interface AppState {
  modelImages: ModelImage[];
  approvedModelImageUrls: string[];
  selectedProducts: Product[];
  moodboards: Moodboard[];
  isLoading: boolean;
  
  // Auto-Style feature toggle
  isAutoStyleModeEnabled: boolean;
  
  // Try-on mode selection
  tryOnMode: "performance" | "balanced" | "quality";
  
  // Processing state for background tasks
  processingMoodboards: Set<string>; // Board IDs currently being processed
  completedMoodboards: Set<string>; // Board IDs that just completed processing
  
  // Chat session management
  chatSessions: ChatSession[];
  chatMessages: Record<string, Message[]>;
  activeChatId: string | null;
  
  setIsLoading: (status: boolean) => void;
  loadModelImages: () => Promise<void>;
  addPlaceholderImage: (url: string) => number;
  updatePlaceholderImage: (id: number, finalState: Omit<ModelImage, 'id'>) => void;
  deleteModelImage: (imageUrl: string) => void;
  toggleAutoStyleMode: () => void;
  toggleProductSelection: (product: Product) => void;
  clearSelectedProducts: () => void;
  addCompletedMoodboard: (board: Moodboard) => void;
  createOrUpdateMoodboard: (title: string, description: string, action: 'CREATE_NEW' | 'ADD_TO_EXISTING', itemsToAdd: Product[], tryOnUrlMap: Record<string, string>) => string;
  updateMoodboardWithTryOns: (boardId: string, tryOnUrlMap: Record<string, string>, categorization?: any) => void;
  deleteMoodboard: (boardId: string) => void;
  deleteAllMoodboards: () => void;
  removeMoodboardItem: (boardId: string, itemId: string) => void;
  
  // Try-on mode management
  setTryOnMode: (mode: "performance" | "balanced" | "quality") => void;
  
  // Processing state management
  setMoodboardProcessing: (boardId: string) => void;
  setMoodboardCompleted: (boardId: string) => void;
  clearCompletedStatus: (boardId: string) => void;
  
  // New chat management actions
  addChatSession: (id: string) => void;
  setChatMessages: (id: string, messages: Message[]) => void;
  setChatTitle: (id: string, title: string) => void;
  setActiveChatId: (id: string | null) => void;
  deleteChatSession: (id: string) => void;
}

export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      modelImages: [],
      approvedModelImageUrls: [],
      selectedProducts: [],
      moodboards: [],
      isLoading: false,
      
      // Initialize Auto-Style mode
      isAutoStyleModeEnabled: false,
      
      // Initialize try-on mode
      tryOnMode: "performance",
      
      // Initialize processing state
      processingMoodboards: new Set<string>(),
      completedMoodboards: new Set<string>(),
      
      // Initialize chat sessions
      chatSessions: [],
      chatMessages: {},
      activeChatId: null,
      
      setIsLoading: (status) => set({ isLoading: status }),
      loadModelImages: async () => {
        try {
          console.log('[Store] Loading model images from server...');
          const res = await fetch('/api/get-model-images');
          const data = await res.json();
          console.log('[Store] Loaded model images:', data.images.length);
          
          const approvedUrls = data.images
            .filter((img: ModelImage) => img.status === 'approved')
            .map((img: ModelImage) => img.url);
          
          set({ 
            modelImages: data.images,
            approvedModelImageUrls: approvedUrls
          });
        } catch (error) {
          console.error('[Store] Failed to load model images:', error);
          set({ modelImages: [], approvedModelImageUrls: [] });
        }
      },
      addPlaceholderImage: (url) => {
        const newId = Date.now() + Math.random();
        const newImage: ModelImage = { id: newId, url, status: 'validating', reason: 'Uploading...' };
        set((state) => ({ modelImages: [...state.modelImages, newImage] }));
        console.log('[Store] Added placeholder image with ID:', newId);
        return newId;
      },
      updatePlaceholderImage: (id, finalState) => {
        console.log('[Store] Updating placeholder image:', id, 'with final state:', finalState);
        set((state) => {
          const updatedModelImages = state.modelImages.map((img) => 
            img.id === id ? { id, ...finalState } : img
          );
          
          const approvedUrls = updatedModelImages
            .filter(img => img.status === 'approved')
            .map(img => img.url);
          
          return {
            modelImages: updatedModelImages,
            approvedModelImageUrls: approvedUrls
          };
        });
      },
      // Removes an image from the local state
      deleteModelImage: (imageUrl) => {
        console.log('[Store] Deleting image with URL:', imageUrl);
        set((state) => {
          const updatedModelImages = state.modelImages.filter(img => img.url !== imageUrl);
          
          const approvedUrls = updatedModelImages
            .filter(img => img.status === 'approved')
            .map(img => img.url);

          return {
            modelImages: updatedModelImages,
            approvedModelImageUrls: approvedUrls,
          };
        });
      },
      toggleAutoStyleMode: () => {
        set((state) => ({ isAutoStyleModeEnabled: !state.isAutoStyleModeEnabled }));
      },
      setTryOnMode: (mode) => {
        set({ tryOnMode: mode });
      },
      toggleProductSelection: (product) => {
        set((state) => {
          const isSelected = state.selectedProducts.some((p) => p.id === product.id);
          return {
            selectedProducts: isSelected
              ? state.selectedProducts.filter((p) => p.id !== product.id)
              : [...state.selectedProducts, product],
          };
        });
      },
      clearSelectedProducts: () => set({ selectedProducts: [] }),
      addCompletedMoodboard: (board: Moodboard) => {
        console.log(`[Store] Adding new auto-generated moodboard: ${board.title}`);
        set(state => ({ moodboards: [...state.moodboards, board] }));
      },
      createOrUpdateMoodboard: (title, description, action, itemsToAdd, tryOnUrlMap) => {
        let boardId = '';
        const newMoodboardItems: MoodboardItem[] = itemsToAdd.map(product => ({
          ...product,
          tryOnUrl: tryOnUrlMap[product.id]
        }));

        set(state => {
          if (action === 'CREATE_NEW') {
            const newId = uuidv4();
            boardId = newId;
            const newMoodboard: Moodboard = {
              id: newId,
              title,
              description,
              items: newMoodboardItems,
            };
            return { moodboards: [...state.moodboards, newMoodboard] };
          } else { // ADD_TO_EXISTING
            const existingBoard = state.moodboards.find(b => b.title === title);
            boardId = existingBoard?.id || '';
            return {
              moodboards: state.moodboards.map(board => 
                board.title === title 
                  ? { ...board, items: [...board.items, ...newMoodboardItems] } 
                  : board
              )
            };
          }
        });
        return boardId;
      },
      
      updateMoodboardWithTryOns: (boardId, tryOnUrlMap, categorization) => {
        set(state => ({
          moodboards: state.moodboards.map(board => {
            if (board.id !== boardId) {
              return board;
            }
            const updatedItems = board.items.map(item => ({
              ...item,
              tryOnUrl: tryOnUrlMap[item.id] || item.tryOnUrl,
            }));
            return { 
              ...board, 
              items: updatedItems,
              // Update title and description if categorization is provided
              ...(categorization && {
                title: categorization.boardTitle,
                description: categorization.boardDescription
              })
            };
          })
        }));
        console.log(`[Store] Upgraded moodboard ${boardId} with new try-on images and categorization.`);
      },

      deleteMoodboard: (boardId) => {
        console.log(`[Store] Deleting moodboard with ID: ${boardId}`);
        set(state => ({
          moodboards: state.moodboards.filter(board => board.id !== boardId)
        }));
      },

      deleteAllMoodboards: () => {
        console.log('[Store] Deleting all moodboards');
        set({ moodboards: [] });
      },

      removeMoodboardItem: (boardId, itemId) => {
        console.log(`[Store] Removing item ${itemId} from moodboard ${boardId}`);
        set(state => ({
          moodboards: state.moodboards.map(board => 
            board.id === boardId
              ? { ...board, items: board.items.filter(item => item.id !== itemId) }
              : board
          )
        }));
      },
      
      // --- NEW ACTIONS FOR CHAT MANAGEMENT ---
      addChatSession: (id) => {
        const newSession: ChatSession = { id, title: 'New conversation', createdAt: new Date() };
        set(state => ({ 
          chatSessions: [...state.chatSessions, newSession],
          activeChatId: id,
        }));
      },

      setChatMessages: (id, messages) => {
        set(state => ({
          chatMessages: {
            ...state.chatMessages,
            [id]: messages
          }
        }));
      },

      setChatTitle: (id, title) => {
        set(state => ({
          chatSessions: state.chatSessions.map(session => 
            session.id === id ? { ...session, title } : session
          )
        }));
      },
      
      setActiveChatId: (id) => set({ activeChatId: id }),

      deleteChatSession: (id) => {
        set(state => {
          const newChatSessions = state.chatSessions.filter(session => session.id !== id);
          const newActiveChatId = state.activeChatId === id ? null : state.activeChatId;
          
          // Also delete messages associated with the chat
          const newChatMessages = { ...state.chatMessages };
          delete newChatMessages[id];
          
          return {
            chatSessions: newChatSessions,
            chatMessages: newChatMessages,
            activeChatId: newActiveChatId,
          };
        });
      },
      
      // Processing state management
      setMoodboardProcessing: (boardId) => {
        set(state => ({
          processingMoodboards: new Set([...state.processingMoodboards, boardId]),
          completedMoodboards: new Set([...state.completedMoodboards].filter(id => id !== boardId))
        }));
      },
      
      setMoodboardCompleted: (boardId) => {
        set(state => ({
          processingMoodboards: new Set([...state.processingMoodboards].filter(id => id !== boardId)),
          completedMoodboards: new Set([...state.completedMoodboards, boardId])
        }));
      },
      
      clearCompletedStatus: (boardId) => {
        set(state => ({
          completedMoodboards: new Set([...state.completedMoodboards].filter(id => id !== boardId))
        }));
      },
    }),
    {
      name: 'ai-fashion-storage',
      partialize: (state) => ({
          modelImages: state.modelImages,
          approvedModelImageUrls: state.approvedModelImageUrls,
          selectedProducts: state.selectedProducts,
          moodboards: state.moodboards,
          isAutoStyleModeEnabled: state.isAutoStyleModeEnabled,
          tryOnMode: state.tryOnMode,
          chatSessions: state.chatSessions, // Persist the chat list
          chatMessages: state.chatMessages, // Persist the chat messages
          activeChatId: state.activeChatId,
          // Don't persist processing states - they should reset on reload
      }),
    }
  )
); 